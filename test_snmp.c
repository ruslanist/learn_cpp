/*
Перед компиляцией установить пакеты, используя эту команду

sudo apt-get install libsnmp-dev libsnmp-base libsnmp30 snmp snmpd

После этого нужно компилировать программу вот такой командой
gcc test_snmp.c -lsnmp

Запускать как обычно,
./a.out

Гуглить: 
"Протокол SNMP"
"Что такое MIB"
"Что такое OID"
*/

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>

int main(int argc, char*argv[]) {

   /*
       Создали переменные которые нужны для функций net-snmp. 
	Они используются как входные параметры для функций net-snmp.
	Для нас они - черный ящик. Нам нет необходимости детально знать, что это за структуры и какие в них есть данные.
   */
   struct snmp_session session, *ss; //здесь создаются две переменные session и ss с типом 'struct snmp_session'. 
   //snmp_session - это тип, как GrandBook. Тут может смущать, нахрена перед ним еще пишут struct. Это ограничения Си
   //В c++ мы могли бы просто написать, как обычно
	// snmp_session session; <---создали объект session с типом snmp_session. 
   struct snmp_pdu *pdu; //аналогично, указатель pdu на тип snmp_pdu. snmp_pdu - это структура ну или класс.
   struct snmp_pdu *response;
           
   oid anOID[MAX_OID_LEN]; //массив anOID размером MAX_OID_LEN с типом oid.
   size_t anOID_len = MAX_OID_LEN;
   
   struct variable_list *vars; //указатель vars на объекты типа variable_list. 
   int status;

   /*
    * В соответствии с правилами этой библиотеки, нужно вначале позвать эту функцию. Можно загуглить "init_snmp" и найти описание для нее. 
      В этом нет особой необходимости, достаточно знать, что она просто подготавливает внутренние структуры библиотеки к работе.
      И клиент библиотеки(т.е. мы, т.е. те, кто использует API этой библиотеки) - должны всегда перед работой звать эту функцию. Иначе
     все остальные функции этой библиотеки будут с ошибкой возвращаться.
    */
   init_snmp("snmpapp");

    /*
    * Опять же, здесь зовется некая функция snmp_sess_init которой передается адрес переменной session.
      Мы не знаем что там эта функция сделает с этой переменной, нам это не важно. Важно просто знать, что мы должны позвать перед работой эту функцию.
    */
   snmp_sess_init( &session );                   /* set up defaults */
   session.peername = "127.0.0.1"; // Здесь мы задаем IP адрес, к которому эта программа будет стучаться. Ну типа айпи адрес Циски с которой нужно получить температуру
//Мы будем опрашивать сами себя, свой локальный компьютер. Поэтому мы пишем IP адрес: 127.0.0.1 - это означает коннектится к самому себе.
   
   /* set the SNMP version number */
   session.version = SNMP_VERSION_1; // это просто задает версию SNMP протокола, который мы планируем использовать. Тоже нет смысла в это углубляться
   
   /* set the SNMPv1 community name used for authentication */
   session.community = "public";  //это что-то вроде пароля. Когда эта программа будет стучаться по айпи адресу на циску..та попросит ввести пароль. На циске задают, что правильный пароль public. И в программе мы соответственно тоже пишем, что вот такой пароль надо отдать и тогда нас пустят на циску.
//В нашем случае, это пароль нашей "локальныйо циский" - т.е. нашего компьюетра, на котором мы запускаем эту программу
   session.community_len = strlen(session.community);  //просто получить длинну пароля. Можешь загуглить эту функцию strlen и посмотреть что она делает. Это п олезно

   /*
    * Open the session
    */
   ss = snmp_open(&session); //опять, некая функция, которую мы должны вызвать в соответствии с правилами библиотеки, но нет необходимости в деталях знать что там.
   if (!ss) { // все что мы должны - это после вызова, проверить возваращаемое значение, если оно фалсе., то значит внутри библиотеки была ошибка и нам надо сообщить об ошибке и завершить программу.
       snmp_perror("ack");
       snmp_log(LOG_ERR, "something horrible happened!!!\n");
       exit(2);
   }

   /*
    * Create the PDU for the data for our request.
    *   1) We're going to GET the system.sysDescr.0 node.
    */
   //Тоже нет необходимости вникать. Здесь создается некий объект pdu, который начиняется какой-то херней. Это что-то вроде сигнала, что мы сейчас будем создавать запрос на получение инфы с циски.
   pdu = snmp_pdu_create(SNMP_MSG_GET);

//Это вот числовое представление конкретной команды, которую мы хотим послать на циску. Его нужно из "xxx.xxx.xxx" поконвертить в массив anOID.
//Это делает вот эта функция. Из строки в массив херачит. Особо тут вникать тоже нет смысла.
   read_objid("1.3.6.1.2.1.1.8.0", anOID, &anOID_len);

   snmp_add_null_var(pdu, anOID, anOID_len); //опять же функция, которая добавляет в конец нашей команды NULL. Это требования библиоотеки. Нет смысла вникать.
   status = snmp_synch_response(ss, pdu, &response); //выполнение запроса. мы шлем наш запрос, который в pdu переменной.  В этот момент случается магия, запрос идет по сети, и сохраняет ответ от циски.
   /*
    * Process the response.
    */
   if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR) {
     /*
      * SUCCESS: Print the result variables
      */
	//Если запрос удался, мы попали сюда и здесь мы просто выводим результаты этого запроса. Опять же используя вот такие хитры функции типа print_variable.
//Вникать нет смысла.
 	for(vars = response->variables; vars; vars = vars->next_variable)
       		print_variable(vars->name, vars->name_length, vars);
   } else {
     /*
      * FAILURE: print what went wrong!
      */
    	//Если не удался запрос - просто возвращаем ошибку и завершаем программу
     	if (status == STAT_SUCCESS) {
       		fprintf(stderr, "Error in packet\nReason: %s\n",
               		snmp_errstring(response->errstat));
     	} else {
       		snmp_sess_perror("snmpget", ss);
	}
   }

	//Библиотека внутри себя выделила ресурсы, мы должны после завершения работы их свободить
   if (response)
     snmp_free_pdu(response); //функция освобохдает ресурсы
   snmp_close(ss); //функция закрывает подключение и сигнализирует библиотеке что мы закончили. библиотека соответствено подчищает все свои внутренние структуры. 
}
